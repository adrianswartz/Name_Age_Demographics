# name_age_demographics

After a decade in experimental condensed matter physics, I am testing the waters of data science. I embarked on my first “project” after teaching myself some basic Python. Since I am taking baby steps, it would be fitting to start with a baby-names project (following the Google web-class). 

However, rather than do a simple analysis of which baby names are popular or unpopular, I wanted to try something that was a bit more useful from a business point of view. I stumbled across this FiveThirtyEight article, https://fivethirtyeight.com/features/how-to-tell-someones-age-when-all-you-know-is-her-name/, which I thought was a great place to start. 

For this project, I want to be able to answer the following question: Given someone’s name, can we know the age of that person? Getting that far would be step one. But suppose I want to sell 90's memorabilia to generation Xers. Then it may be helpful to include a character in my advertisement which has a very "characteristically popular" Gen X name. What name should I chose? 

To answer these questions, I first downloaded the baby-names data from the Social Security Administration website (SSA, https://www.ssa.gov/oact/babynames/limits.html).  From this website you can access the National or State data. I downloaded the National data as a zip file from 1880 to 2017. These files are included in the "names.zip" (name_age.py and demographics.py accesses the sub-directory "/names").

Additionally, it makes sense to consider whether or not the name searched for is likely to be alive today. For this, we can add an age filter to the data by including information from actuarial tables from the SSA. I downloaded the actuarial table from 2014 and converted these to “probability to be alive” in 2017 (code: get_actdata_2014.py). This information is stored in a text file (adj_act_data_2014.txt) which is used by the main programs (name_age.py, demographics.py). I have separated Male from Female death rates. For simplicity, I have made the following assumptions: 1) All names for one sex have the same death probabilities, and 2) the actuarial table for 2014 can be applied in 2017. 

Next, I wrote a simple program (name_age.py) which asks for a name and the sex (M or F) and subsequently calculates the average age, median age, standard deviation, skewness, and kurtosis from the distribution of people with that name who are still likely to still be alive in 2017.  Using this little program I was able to compare my approach with FiveThirtyEight’s results and it was satisfying to reproduce their interpretation. However, it is clear that there are many oversimplifications with this analysis. For instance, a single normal distribution cannot describe many names and so the analysis that FiveThirtyEight presents is not meaningful across the board. I want to identify names which are "characteristically popular" for different demographics. Therefore, I want to identify names which are vastly popular for a relatively short amount of time, or in other words, which have a sharp distribution exceeding some minimum popularity threshold. For instance, from playing around with the name_age.py program, we can say with a high degree of confidence that Brittany is a millennial and Barbara is a baby boomer.   

I wanted to compile this information for all names in the SSA data so long as the name is relevant enough (i.e. > 400,000 people all time). Then filter this list to find those names which are "characteristic" of different generations.  I wrote a program which does this called demographics.py. Check out the header comments of demographics.py to see more details about what the program does. In essence, it compiles all SSA data (baby names and actuarial table), patches both of them, and then runs statistics on a subset based on popularity (of your choosing). The results binned by demographics are simply printed to the terminal.

And for my (hypothetical) ad campaign for 90's memorabilia, I should consider: "Jennifer", "Lisa", "Kimberly", "Mark", "Jason", and/or "Jefferey".  

Feel free to take a look, test the code, and please let me know if you have any suggestions for improving the project!
